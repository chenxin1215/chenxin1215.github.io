---
title: 什么是归并排序？
date: 2024-02-27 21:17:34
tags:
    - 排序算法
categories: 算法
---

<meta name="referrer" content="no-referrer"/>

#### 一、思路
使用分治的思想进行排序，对于一个长度为n的序列，将其拆分为两个长度为 `n/2`的子序列。
然后每次递归调用函数使子序列有序，再线性的合并两个有序的子序列，使整个序列有序。
重点有两个：
    1. 拆分为两个子序列，并进行递归调用，对子序列排序。
    2. 线性合并两个有序的子序列，使整体有序。

#### 二、具体算法
假设我们定义`mergeSort(nums, l, r)`函数表示对`nums`数组里的`[l, r]`部分进行排序，函数的流程如下：

1. 计算当前区间的中点下标`mid = (r - l) / 2`
2. 递归调用函数 `mergeSort(nums, l, mid)`对`nums`数组里面的`[l, mid]`部分进行排序。
3. 递归调用函数 `mergeSort(nums, mid+1, r)`对`nums`数组里面的`[mid+1, r]`部分进行排序。
4. 此时，`nums`数组里面的`[l, mid]`部分和`[mid+1, r]`部分都已经有序，我们对两个有序区间进行线性合并即可。
5. 线性归并的过程：由于两个区间都是有序的，所以我们维护两个指针`i`和`j`分别指向两个区间的起点，以及一个临时数组，存放有序的序列；然后对任意区间进行遍历，如果`nums[i] <= nums[j]`那么我们将`nums[i]`放入临时数组，否则就将`nums[j]`放入临时数组，全部遍历完成后，再将剩下多余的数组全部放入临时数组。

    示意图：
![912_fig4.gif](https://cdn.nlark.com/yuque/0/2024/gif/29411486/1708679447471-48886431-fbbf-418c-8b06-10589886216b.gif#averageHue=%23fdfcfc&clientId=uf5ec3c44-d104-4&from=drop&id=u236af1f9&originHeight=448&originWidth=805&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=1220304&status=done&style=stroke&taskId=u6215349f-2155-4f83-81dd-adda4c5ff56&title=)

#### 三、示例代码
这里以Java代码为例，展示标准的归并排序算法：

```
public class Solution {

    public static void main(String[] args) {

        int[] sortArray = new Solution().sortArray(new int[] {5, 1, 1, 2, 0, 0});
        for (int i = 0; i < sortArray.length; i++) {
            System.out.print(sortArray[i]);
        }

    }

    // 创建全局的临时区间, 可以防止每次递归调用都创建新的数组
    int[] temp;

    /**
     * 归并排序
     *
     * @param nums
     * @author: chenXin
     * @date: 2024/2/23
     */
    public int[] sortArray(int[] nums) {
        temp = new int[nums.length];
        mergeSort(nums, 0, nums.length - 1);
        return nums;
    }

    public void mergeSort(int[] nums, int l, int r) {
        if (l >= r) {
            return;
        }

        // 计算中点
        int mid = (r + l) >> 1;

        // 拆分为两个序列，并进行递归调用
        mergeSort(nums, l, mid);
        mergeSort(nums, mid + 1, r);

        // 合并线性序列 保证整体区间有序
        mergeNums(nums, l, r, mid);

    }

    /**
     * 合并线性序列
     */
    private void mergeNums(int[] nums, int l, int r, int mid) {
        int k = 0, i = l, j = mid + 1;

        // 遍历左边的区间 将小的放入临时区间
        while (i < mid + 1 && j < r + 1) {
            if (nums[i] <= nums[j]) {
                temp[k++] = nums[i++];
            } else {
                temp[k++] = nums[j++];
            }
        }

        // 剩余的直接放入临时区间
        while (i < mid + 1) {
            temp[k++] = nums[i++];
        }
        while (j < r + 1) {
            temp[k++] = nums[j++];
        }

        // 把临时区间赋值给nums
        for (int m = 0; m < k; m++) {
            nums[l + m] = temp[m];
        }
    }

}
```
